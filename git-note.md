# git 学习笔记
> 为什么呢？如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？
这个软件用起来就应该像这个样子，能记录每次文件的改动：

| 版本        | 用户           | 说明  | 日期|
| ------------- |:-------------:| -----:|-----:|
| 1      |张三 | 删除了软件服务条款5 | 7/12 10:38|
| 2      |张三 | 增加了License人数限制 | 7/12 18:09|
| 3      |李四 | 财务部门调整了合同金额 | 7/13 9:51|
| 4      |张三 | 延长了免费升级周期 | 7/14 15:17|

## 创建版本库
>什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。

> 创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：

* $ `mkdir learngit`
* $ `cd learngit`
* $ `pwd`
* /Users/michael/learngit

> pwd命令用于显示当前目录。在我的Mac上，这个仓库位于/Users/michael/learngit。

*  `git init` 初始化一个版本库
* `git add <file>` 可反复多次使用，添加多个文件
* `git commit` 把文件提交到仓库

## 时光穿梭机
> 每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。

* `git diff` 查看工作区雨暂存区的不同
* `git status` 仓库当前的状态
* `git log` 显示从最近到最远的提交日志
* `git log --oneline` 单行显示提交日志
* `git reflog` 用来记录你的每一次命令

> Git reflog 可以查看所有分支的所有操作记录（包括（包括commit和reset的操作），包括已经被删除的commit记录，git log则不能察看已经删除了的commit记录


> Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：

1. 用`git add`把文件添加进去，实际上就是把文件修改添加到暂存区；

2. 用`git commit`提交更改，实际上就是把暂存区的所有内容提交到当前分支。

#### 撤销修改

* 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令`git checkout -- file`。
* 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令`git reset HEAD file`，就回到了场景1，第二步按场景1操作。
* 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。

> 在Git中，删除也是一个修改操作。一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用`rm`命令删了

* `rm test.txt` 从文件管理器中删除test.txt
* `git rm test.txt` 删除暂存区的test.txt
* `git commit -m "remove test.txt` 提交暂存区的删除操作
* `git checkout -- test.txt` 还原工作区的误删操作

## 远程仓库
> 本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，即运用的是公钥登录.所谓"公钥登录"，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。
创建ssh key:

* `ssh-keygen -t rsa -C "youremail@example.com"`

> GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。

#### 添加远程仓库

> 要关联一个远程库，使用命令`git remote add origin git@server-name:path/repo-name.git`；
关联后，使用命令`git push -u origin master`第一次推送master分支的所有内容；
此后，每次本地提交后，只要有必要，就可以使用命令`git push origin master`推送最新修改；
分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！『其中origin可以是任意名字 代表远程库的名字，默认叫法就是origin』

#### 克隆远程仓库
>先创建远程库并初始化，然后，从远程库克隆。

* `git clone git@github.com:qiuguixin/gitskills.git`

> 将远程github上的gitskills仓库克隆到本地当前目录下

## 分支管理
>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。
现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。

#### 创建与合并分支
> 因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全

* `git branch` 查看分支
* `git branch 分支名字` 创建分支
* `git checkout 分支名字` 切换分支
* `git checkout -b 分支名字` 创建+切换分支
* `git merge 分支名字` 合并某分支到当前分支
* `git branch -d 分支名字` 删除分支

#### 解决冲突
> 当对主分支master和其他分支例如feature分支的同一文件都进行过更改，然后将feature分支合并到master分支上时，会产生冲突，这时，要手动解决冲突，然后再提交，合并完成。

* `git log --graph --pretty=oneline --abbrev-commit`

> 用以上命令可以查看分支合并图 

####分支管理策略
> 通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。
如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。

* `git merge --no-ff -m "merge with no-ff" dev`

> 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。

> 在实际开发中，我们应该按照几个基本原则进行分支管理：首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。

#### Bug分支
> 在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作.

* `git stash` 保存工作现场
* `git stash list` 显示保存的工作现场列表
* `git stash apply` 恢复工作现场，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；
* `git stash pop` 恢复的同时把stash内容也删了

> 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；

> 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再`git stash pop`，回到工作现场。

#### Feature分支
> 开发一个新feature，最好新建一个分支；

> 如果要丢弃一个没有被合并过的分支，可以通过`git branch -D <name>`强行删除。

#### 多人协作
> 多人协作的工作模式通常是这样：

1. 首先，可以试图用`git push origin branch-name`推送自己的修改；

2. 如果推送失败，则因为远程分支比你的本地更新，需要先用`git pull`试图合并；

3. 如果合并有冲突，则解决冲突，并在本地提交；

4. 没有冲突或者解决掉冲突后，再用`git push origin branch-name`推送就能成功！

> 如果`git pull`提示`“no tracking information”`，则说明本地分支和远程分支的链接关系没有创建，用命令`git branch --set-upstream branch-name origin/branch-name`。

> 这就是多人协作的工作模式，一旦熟悉了，就非常简单。

* 查看远程库信息，使用`git remote -v`；
* 用`git remote rm yuancheng` 解除与远程仓库的关联
* 本地新建的分支如果不推送到远程，对其他人就是不可见的；

* 从本地推送分支，使用`git push origin branch-name`，如果推送失败，先用`git pull`抓取远程的新提交；

* 在本地创建和远程分支对应的分支，使用`git checkout -b branch-name origin/branch-name`，本地和远程分支的名称最好一致；

* 建立本地分支和远程分支的关联，使用`git branch --set-upstream branch-name origin/branch-name`；

* 从远程抓取分支，使用`git pull`，如果有冲突，要先处理冲突。

## 标签管理
> 标签是版本库的一个快照。

> 但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。

> Git有commit，为什么还要引入tag？

> “请把上周一的那个版本打包发布，commit号是6a5819e...”

> “一串乱七八糟的数字不好找！”

> 如果换一个办法：

> “请把上周一的那个版本打包发布，版本号是v1.2”

> “好的，按照tag v1.2查找commit就行！”

> 所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。

#### 创建标签
> 在Git中打标签非常简单，首先，切换到需要打标签的分支上，然后，敲命令`git tag 标签名`就可以打一个新标签，默认标签是打在最新提交的commit上的

> 要对历史提交打标签?找到历史提交的commit id,然后敲命令`git tag 标签名 commit id`

> 用命令`git show 标签名`可以看到对应提交的详情

> 用命令`git tag -a 标签名 -m "blablabla..."` 创建标签+指定标签信息

> 用命令`git tag` 可以查看所有标签

#### 操作标签
>主要是删除和推送标签到远程的操作

* 命令`git push origin <tagname>`可以推送一个本地标签；
* 命令`git push origin --tags`可以推送全部未推送过的本地标签；
* 命令`git tag -d <tagname>`可以删除一个本地标签；
* 命令`git push origin :refs/tags/<tagname>`可以删除一个远程标签。

## 使用GitHub
> GitHub是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。

* 在GitHub上，可以任意Fork开源仓库；

* 自己拥有Fork后的仓库的读写权限；

* 可以推送pull request给官方仓库来贡献代码。

### 附
>常用shell命令

* `pwd` 显示当前目录
* `ls` 当前目录下所有文件
* `mkdir 目录名` 新建目录
* `touch 文件名` 新建文件
* `rm 文件名` 删除文件
* `rm -rf 目录名` 把子目录及子目录中所有档案删除,并且不用一一确认 
* `cat 文件名` 查看文件内容
* `cd  目标目录` 切换到目标目录
* `mv  原名 新名` 重命名
* `vi 文件名` vim 中编辑文件







